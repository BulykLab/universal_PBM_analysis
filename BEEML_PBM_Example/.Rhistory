pred = predict.occupancy(new.mtx,0, seqs.01, v2.probes.8mer.idx.f[,1:30], v2.probes.8mer.idx.r[,1:30], x$pos.weights, x$f.weight, x$r.weight, boltzmann=T)
pred.8mers = unlist(lapply(v2.8mer.probes.idx[good.8mer.idx], function(x) median(pred[x])))#
    plot(pred.8mers, v2.8mer.medians[,i])#
    abline(lm(v2.8mer.medians[,i]~pred.8mers))#
    summary(lm(v2.8mer.medians[,i]~pred.8mers))
new.mtx
matrix(new.mtx,4)
print.logo(new.mtx)
sol2 = get.beeml.solution.sum(v1[,i], v1.probes.8mer.idx.f[,1:30], v1.probes.8mer.idx.r[,1:30], x$pos.weights, uniprobe.pwm, seqs.01, F, 1, F, 5, 0, boltzmann=F, x$f.weight, x$r.weight)
sol2
sol
plot(sol2$par[1:30],sol$par)
length(sol$par)
plot(sol2$par[1:24],sol$par)
matrix(sol2$par[1:24],3)
matrix(sol$par[1:24],3)
new.pwm = uniprobe.pwm
new.pwm[new.pwm>0] = sol2$par[1:24]
print.logo(new.pwm)
print.logo(uniprobe.pwm)
pred = predict.occupancy(new.pwm,0,seqs.01,v1.probes.8mer.idx.f[,1:30], v1.probes.8mer.idx.r[,1:30], x$pos.weights, x$f.weight, x$r.weight, boltzmann=T)
plot(pred, v1[,i])
colnames(v1)[i]
grep("Hnf",colnames(v1))
pred.8mers = unlist(lapply(v2.8mer.probes.idx[good.8mer.idx], function(x) median(pred[x])))#
    plot(pred.8mers, v2.8mer.medians[,i])#
    abline(lm(v2.8mer.medians[,i]~pred.8mers))#
    summary(lm(v2.8mer.medians[,i]~pred.8mers))
pred = predict.occupancy(new.pwm,0,seqs.01,v2.probes.8mer.idx.f[,1:30], v2.probes.8mer.idx.r[,1:30], x$pos.weights, x$f.weight, x$r.weight, boltzmann=T)
pred.8mers = unlist(lapply(v2.8mer.probes.idx[good.8mer.idx], function(x) median(pred[x])))#
    plot(pred.8mers, v2.8mer.medians[,i])#
    abline(lm(v2.8mer.medians[,i]~pred.8mers))#
    summary(lm(v2.8mer.medians[,i]~pred.8mers))
results
plot(pred, v2[,i])
abline(lm(v2[,i]~pred))
summary(lm(v2[,i]~pred))
new.pwm
matrix(new.pwm,4)
apply(matrix(new.pwm,4),2,function(x) x-min(x))
new.pwm2 = apply(matrix(new.pwm,4),2,function(x) x-min(x))
new.pwm2 = as.vector(apply(matrix(new.pwm,4),2,function(x) x-min(x)))
new.pwm2[new.pwm2>log(1e3)]=log(1e3)
matrix(new.pwm2,4)
pred2 = predict.occupancy(new.pwm2,0,seqs.01,v2.probes.8mer.idx.f[,1:30], v2.probes.8mer.idx.r[,1:30], x$pos.weights, x$f.weight, x$r.weight, boltzmann=T)
plot(pred,pred2)
abline(0,1)
pred2.8mers = unlist(lapply(v2.8mer.probes.idx[good.8mer.idx], function(x) median(pred2[x])))#
     plot(pred2.8mers, v2.8mer.medians[,i])#
     abline(lm(v2.8mer.medians[,i]~pred2.8mers))#
     summary(lm(v2.8mer.medians[,i]~pred2.8mers))
seqLogo(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1])
seqLogo(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1]))
seqLogo(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1]
read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1]
read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")
read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1]
seqLogo(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1])
read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1][5:14]
apply(-log(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1][5:14]),2,function(x) x-min(x))
as.vector(apply(-log(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1][5:14]),2,function(x) x-min(x)))
uniprobe.pwm.10 = as.vector(apply(-log(read.table("/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Badis Science 09/Hnf4a/Hnf4a_pwm_primary.txt",comment.char="P")[,-1][5:14]),2,function(x) x-min(x)))
print.logo(uniprobe.pwm.10)
seqs.01.10 = make.kmers.01(10)
gc(T)
seqs.01.10 = make.kmers.01(10)
gc(T)
seqs.01.10 = make.kmers.01(10)
dim(seqs.01.10)
seqs.01.10 = make.kmers.01(10)
ls()
gc(T)
sort(sapply(ls(), function(x) object.size(get(x))))
rm(r1)
rm(pr)
rm(pf)
rm(y)
rm(rev.seqs)
rm(seqs)
rm(values)
rm(fow.seqs)
rm(design)
rm(m)
gc(T)
seqs.01.10 = make.kmers.01(10)
rm(seqs.01)
gc(T)
seqs.01 = make.kmers.01(10)
gc(T)
ls()
load("~/Documents/work/PBM_Analysis/Data/Badis09/v1.RData")#
load("~/Documents/work/PBM_Analysis/Data/Badis09/v2.RData")#
source("~/Documents/work/PBM_Analysis/src/code.R")#
source("~/Documents/work/PBM_Analysis/src/util.R")#
#
get.high.information.positions <- function(mtx, k, energy.mtx = T) {#
  if (energy.mtx) {#
    freq.mtx = apply(matrix(exp(-mtx),4),2,function(x) x/sum(x))#
  } else {#
    freq.mtx = mtx#
  }#
  entropy = apply(freq.mtx,2,function(x) sum(x*-log(x)))#
  start = which.min(sapply(1:(length(entropy)-k+1), function(x) sum(entropy[x:(x+k-1)])))#
  as.vector(apply(-log(freq.mtx[,start:(start+k-1)]),2,function(x) x-min(x)))#
}#
#
get.kmer.intensity.ratios <- function(kmer,seqs,intensities, ratio=T, both.orientations =T) {#
  pos = c()#
  int = c()#
#
  # palidromic kmers only occur on 16 sequences#
  matches.idx = grep(kmer,seqs)#
  for (idx in matches.idx) {#
    location = as.integer(regexpr(kmer,seqs[idx]))#
    pos = c(pos, location)#
    int = c(int, intensities[idx])#
  }#
  #
  if (both.orientations) {#
    kmer.revcomp = decode01(rev(encode01(kmer)))#
    if ( kmer != kmer.revcomp) {#
      matches.idx = grep(kmer.revcomp, seqs)#
      for (idx in matches.idx) {#
        location = as.integer(regexpr(kmer.revcomp,seqs[idx]))#
        pos = c(pos, location)#
        int = c(int, intensities[idx])#
      }#
    }#
  }#
  if (ratio) int = int/mean(int, na.rm=T)#
  cbind(pos,int)#
}#
#
est.orientation.weight <- function(pwm, seqs.01, seqs, values, top=25, smooth=F, kmers = NULL) {#
   seqs = seqs[!is.na(values)]#
   values = values[!is.na(values)]#
#
   if (is.null(kmers)){#
     energy = seqs.01 %*% pwm#
     ## get the top i = 25 kmers according to the matrix,estimate position effect based on them#
     kmers = apply(seqs.01[order(energy)[1:top],],1,decode01)#
   } else {#
     top = length(kmers)#
   }#
   #
#
   l = unlist(sapply(1:25, function(q) {#
               kmer = kmers[q]#
               kmer.rc = decode01(rev(encode01(kmer)))#
               idx.kmer = grep(kmer, seqs)#
               idx.kmer.rc = grep(kmer.rc, seqs)#
               pos.kmer = unlist(gregexpr(kmer, seqs[idx.kmer]))#
               pos.kmer.rc = unlist(gregexpr(kmer.rc, seqs[idx.kmer.rc]))#
               common = unique(intersect(pos.kmer,pos.kmer.rc))#
               sapply(unique(intersect(pos.kmer,pos.kmer.rc)),function(z) mean(values[idx.kmer[pos.kmer==z]]) / mean(values[idx.kmer.rc[pos.kmer.rc==z]]) )#
             }))#
   median(l,na.rm=T)#
 }#
#
est.position.weights <- function(pwm, seqs.01, seqs, values, kmers = NULL, top=25, smooth=F,both.orientations =T) {#
  seqs = seqs[!is.na(values)]#
  values = values[!is.na(values)]#
  #
  if (is.null(kmers)) {#
    energy = seqs.01 %*% pwm#
    # get the top kmers according to the matrix,estimate position effect based on them#
    kmers = apply(seqs.01[order(energy)[1:top],],1,decode01)#
  } else { #
    # use given kmers to estimate position effect#
    top = length(kmers)#
  }#
  # weights are averaged over top 100 8mers, effect of position on intensity level#
  d = get.kmer.intensity.ratios(kmers[1], seqs, values, both.orientations = both.orientations)#
  for(j in 2:top) d = rbind(d,get.kmer.intensity.ratios(kmers[j], seqs, values))#
    pos = sort(unique(d[,1]))#
    for (j in 1:length(pos)) #
      if (j != pos[j]) {#
        j = j - 1#
        break#
    }#
  weights = sapply(1:j, function(idx) mean(d[d[,1]==idx,2],na.rm=T))#
#
  # do some reasonably agreesive smoothing on the weights make f value smaller to do less smoothing#
  if (smooth) weights = lowess(1:length(weights),weights,f=1/5)$y#
  # since we are extending into the constant region, assume the last weight holds for the rest of them#
  weights/sum(weights)#
}#
#
est.bg.weights <- function(values, num.bins=200, lowess.f=0.1) {#
#
  ## estimate lower half of background distribution (upper ground is convoluted with binding signal)#
  ## make a histogram of #
  norm.values = (values - median(values))/mad(values)#
##  bg.values = values[norm.values < 1 & values > 0]  #
  bg.values = values[norm.values < 2 ]#
  #
  h = hist(bg.values,nclass=num.bins,plot=F)#
  #
  ## lowess smoothing to get better density estimate#
  total = lowess(h$mids,h$counts,f=lowess.f)#
  x.lower = total$x[1:which.max(total$y)]#
  y.lower = total$y[1:which.max(total$y)]#
#
  # assume background distribution is symmetrical, so upper tail is just the mirror image of the lower tail#
  x.upper = rev(sapply(x.lower, function(x) x + 2 * (max(x.lower - x))))#
  y.upper = rev(y.lower)#
  x.upper = x.upper[2:length(x.upper)]#
  y.upper = y.upper[2:length(y.upper)]#
  bg = list(x = c(x.lower, x.upper), y = c(y.lower, y.upper))  #
  if (length(total$x) > length(bg$x)) {#
    total = list(x = total$x[1:length(bg$x)], y = total$y[1:length(bg$y)])#
  } else {#
    bg = list(x=bg$x[1:length(total$x)], y = bg$y[1:length(total$y)])#
  }#
  bin.width = (bg$x[2]-bg$x[1])#
  bin.weight = rep(0,length(bg$x))#
  start = which.max(bg$y)#
  total = sapply(start:length(bg$x), function(x) sum(values > bg$x[x] - bin.width/2 & values < bg$x[x] + bin.width/2))#
  bg.exp = bg$y[start:length(bg$x)]#
  bin.weight[start:length(bg$x)] = (total-bg.exp)/total#
  bin.weight[bin.weight<0] = 0#
#  bin.weight = (total$y-bg$y)/total$y#
  bin.weight = round(bin.weight,2)#
#
  probe.weights = rep(0,length(values))#
  bin.begin = bg$x[bin.weight>0] - bin.width/2#
  bin.end = bg$x[bin.weight>0] + bin.width/2#
  for (i in 1:length(bin.begin)) probe.weights[values > bin.begin[i] & values < bin.end[i]] = bin.weight[bin.weight>0][i]#
  probe.weights[values > bin.end[length(bin.end)]] = 1#
  probe.weights#
}
library(Rcpp)
   gslrng <- '#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '#
#
    ## turn into a function that R can call#
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway#
    funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      cppargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")#
    print(funx(0, 5))
library(inline)
funx <- cfunction(signature(s="numeric", n="numeric"),#
                       gslrng,#
                       includes="#include <gsl/gsl_rng.h>",#
                       Rcpp=TRUE,#
                       cppargs="-I/usr/include",#
                       libargs="-lgsl -lgslcblas")
sigSq <- signature(n="integer", x="numeric") #
codeSq <- " #
for (int i=0; i < *n; i++) { #
x[i] = x[i]*x[i]; #
}" #
sigQd <- signature(n="integer", x="numeric") #
codeQd <- " #
squarefn(n, x); #
squarefn(n, x); #
" #
fns <- cfunction( list(squarefn=sigSq, quadfn=sigQd), #
list(codeSq, codeQd), #
convention=".C") #
squarefn <- fns[["squarefn"]]
quadfn <- fns[["quadfn"]] #
squarefn(n, x)$x
x <- as.numeric(1:10) #
n <- as.integer(10)
squarefn(n, x)$x
   gslrng <- '#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '#
#
    ## turn into a function that R can call#
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway#
    funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      #
                      cxxargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")#
    print(funx(0, 5))
   gslrng <- "#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    "#
#
    ## turn into a function that R can call#
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway#
    funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      #
                      cxxargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")#
    print(funx(0, 5))
gslrng
require(Rcpp)
require(inline)
inc <- '#
#
	const char* hello( std::string who ){#
     		std::string result( "hello " ) ;#
     		result += who ;#
     		return result.c_str() ;#
	}#
	#
'#
code <- '#
	Environment g = Environment::global_env() ;#
	g["hello"] = InternalFunction( &hello ) ;#
	return R_NilValue ;#
'#
fx <- cxxfunction( signature(), code, inc, plugin = "Rcpp" )#
f <- fx() # force loading the dynamic library#
#
hello( "world" )
fx <- cxxfunction(signature, gslrng, inc, plugin = "Rcpp")
funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      cppargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")
require(RCpp)
library(Rcpp)
library(inline)
   ## now use Rcpp to pass down a parameter for the seed, and a vector size#
    gslrng <- '#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '
   funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      cppargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")
fx <- cxxfunction( signature(x = "integer", y = "numeric" ) , '#
int dim = as( x ) ;#
arma::mat z = as(y) * arma::eye( dim, dim ) ;#
return wrap( arma::accu(z) ) ;#
', plugin = "RcppArmadillo" )#
fx( 2L, 5 )
inc <- '#
#
	const char* hello( std::string who ){#
     		std::string result( "hello " ) ;#
     		result += who ;#
     		return result.c_str() ;#
	}#
	#
'#
code <- '#
	Environment g = Environment::global_env() ;#
	g["hello"] = InternalFunction( &hello ) ;#
	return R_NilValue ;#
'#
fx <- cxxfunction( signature(), code, inc, plugin = "Rcpp" )#
f <- fx() # force loading the dynamic library#
#
hello( "world" )
x <- as.numeric(1:10)#
n <- as.integer(10)#
#
## Not run: #
## A simple Fortran example#
code <- "#
      integer i#
      do 1 i=1, n(1)#
    1 x(i) = x(i)**3#
"#
cubefn <- cfunction(signature(n="integer", x="numeric"), code, convention=".Fortran")#
#
cubefn(n, x)$x
sigSq <- signature(n="integer", x="numeric")#
codeSq <- "#
  for (int i=0; i < *n; i++) {#
    x[i] = x[i]*x[i];#
  }"#
sigQd <- signature(n="integer", x="numeric")#
codeQd <- "#
  squarefn(n, x);#
  squarefn(n, x);#
"#
#
fns <- cfunction( list(squarefn=sigSq, quadfn=sigQd), #
                  list(codeSq, codeQd), #
                  convention=".C")#
#
squarefn <- fns[["squarefn"]]#
quadfn <- fns[["quadfn"]]#
#
squarefn(n, x)$x#
quadfn(n, x)$x
system.time({sapply(1:1e6, function(z) squarefn(n,x))})
system.time({for( i in 1:100) function(z) squarefn(n,x)})
system.time({for( i in 1:1000) function(z) squarefn(n,x)})
system.time({for( i in 1:1e6) function(z) squarefn(n,x)})
squarefn(n,x)
rsquarefn<- function(x) {
x^2
}
rsquarefn(x)
system.time({for( i in 1:1e6) function(z) rsquarefn(n,x)})
system.time({for( i in 1:1e6) function(z) squarefn(n,x)})
library(RcppExamples)
print(RcppVectorExample(1:5,"new"))
   ## now use Rcpp to pass down a parameter for the seed, and a vector size#
    gslrng <- '#
       #include <Rcpp.h>#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '
 funx <- cfunction(signature(s="numeric", n="numeric"),#
                      gslrng,#
                      includes="#include <gsl/gsl_rng.h>",#
                      Rcpp=TRUE,#
                      cppargs="-I/usr/include",#
                      libargs="-lgsl -lgslcblas")
   ## now use Rcpp to pass down a parameter for the seed, and a vector size#
    gslrng <- '#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '
src <- ' Rcpp::NumericVector xa(a);
Rcpp::NumericVector xb(b);
int n_xa = xa.size(), n_xb = xb.size();
Rcpp::NumericVector xab(n_xa + n_xb - 1);
for (int i = 0; i < n_xa; i++)for (int j = 0; j < n_xb; j++) xab[i + j] += xa[i] * xb[j];return xab;
fun <- cfunction( signature(a="numeric", b="numeric"), src, Rcpp=TRUE)
'
src <- ' Rcpp::NumericVector xa(a);#
 Rcpp::NumericVector xb(b);#
 int n_xa = xa.size(), n_xb = xb.size();#
 Rcpp::NumericVector xab(n_xa + n_xb - 1);#
 for (int i = 0; i < n_xa; i++)#
 for (int j = 0; j < n_xb; j++) xab[i + j] += xa[i] * xb[j];#
 return xab;#
 '
 fun <- cfunction( signature(a="numeric", b="numeric"), src, Rcpp=TRUE)
fun(1:5, 5:10)
src <- ' Rcpp::List input(data); Rcpp::Function f(fun) ; Rcpp::List output(input.size()); std::transform(input.begin(), input.end(), output.begin(), f);
output.names() = input.names() ; return output ; 'cpp_lapply <- cfunction( signature(data="list", fun = "function"), src, Rcpp = TRUE )
cpp_lapply(faithful, summary )
RcppExport SEXP convolve2cpp(SEXP a,SEXP b) { RcppVector<double> xa(a); RcppVector<double> xb(b); int nab = xa.size() + xb.size() - 1;RcppVector<double> xab(nab); for (int i = 0; i < nab; i++) xab(i) = 0.0;for (int i = 0; i < xa.size(); i++) for (int j = 0; j < xb.size(); j++)xab(i + j) += xa(i) * xb(j);RcppResultSet rs; rs.add("ab", xab); return rs.getReturnList(); }
src <- 'RcppExport SEXP convolve2cpp(SEXP a,SEXP b) { RcppVector<double> xa(a); RcppVector<double> xb(b); int nab = xa.size() + xb.size() - 1;RcppVector<double> xab(nab); for (int i = 0; i < nab; i++) xab(i) = 0.0;for (int i = 0; i < xa.size(); i++) for (int j = 0; j < xb.size(); j++)xab(i + j) += xa(i) * xb(j);RcppResultSet rs; rs.add("ab", xab); return rs.getReturnList(); }'
cpp_lapply <- cfunction( signature(data="list", fun = "function"), src, Rcpp = TRUE )
src <- ' Rcpp::NumericVector xa(a);#
 Rcpp::NumericVector xb(b);#
 int n_xa = xa.size(), n_xb = xb.size();#
 Rcpp::NumericVector xab(n_xa + n_xb - 1);#
 for (int i = 0; i < n_xa; i++)#
 for (int j = 0; j < n_xb; j++) xab[i + j] += xa[i] * xb[j];#
 return xab;#
 '
src <- ' Rcpp::List input(data); Rcpp::Function f(fun) ; Rcpp::List output(input.size()); std::transform(input.begin(), input.end(), output.begin(), f);
output.names() = input.names() ; return output ; 'cpp_lapply <- cfunction( signature(data="list", fun = "function"), src, Rcpp = TRUE )
faithful
src <- ' Rcpp::NumericVector xa(a);#
 Rcpp::NumericVector xb(b);#
 int n_xa = xa.size(), n_xb = xb.size();#
 Rcpp::NumericVector xab(n_xa + n_xb - 1);#
 for (int i = 0; i < n_xa; i++)#
 for (int j = 0; j < n_xb; j++) xab[i + j] += xa[i] * xb[j];#
 return xab;#
 '
fun <- cfunction( signature(a="numeric", b="numeric"), src, Rcpp=TRUE)
fun(1:10, 2:11)
fun(1:2, 9:10)
plot(fun(1:10, 2:11))
    gslrng <- '#
       int seed = RcppSexp(s).asInt();#
       int len = RcppSexp(n).asInt();#
#
       gsl_rng *r;#
       gsl_rng_env_setup();#
       std::vector<double> v(len);#
#
       r = gsl_rng_alloc (gsl_rng_default);#
#
       gsl_rng_set (r, (unsigned long) seed);#
       for (int i=0; i<len; i++) {#
           v[i] = gsl_rng_get (r);#
       }#
       gsl_rng_free(r);#
#
       return RcppSexp(v).asSexp();#
    '
 firstExample <- function() {#
     ## a really simple C program calling three functions from the GSL#
     gslrng <- '#
     gsl_rng *r;#
     gsl_rng_env_setup();#
     double v;#
 #
     r = gsl_rng_alloc (gsl_rng_default);#
 #
     printf("generator type: %s\\n", gsl_rng_name (r));#
     printf("seed = %lu\\n", gsl_rng_default_seed);#
     v = gsl_rng_get (r);#
     printf("first value = %.0f\\n", v);#
 #
     gsl_rng_free(r);#
     return R_NilValue;#
     '#
 #
     ## turn into a function that R can call#
     ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway#
     funx <- cfunction(signature(), gslrng,#
                       includes="#include <gsl/gsl_rng.h>",#
                       Rcpp=FALSE,#
                       cppargs="-I/usr/include",#
                       libargs="-lgsl -lgslcblas")#
 #
     cat("Calling first example\n")#
     funx()#
     invisible(NULL)#
}
firstExample()
     gslrng <- '#
     int seed = Rcpp::as<int>(par) ;#
     gsl_rng *r;#
     gsl_rng_env_setup();#
     double v;#
 #
     r = gsl_rng_alloc (gsl_rng_default);#
 #
     gsl_rng_set (r, (unsigned long) seed);#
     v = gsl_rng_get (r);#
 #
     #ifndef BeSilent#
    printf("generator type: %s\\n", gsl_rng_name (r));#
     printf("seed = %d\\n", seed);#
     printf("first value = %.0f\\n", v);#
     #endif#
 #
     gsl_rng_free(r);#
     return Rcpp::wrap(v) ;#
     '
funx <- cfunction(signature(par="numeric"), gslrng,#
                       includes="#include <gsl/gsl_rng.h>",#
                       Rcpp=TRUE)
funx(0)
funx(10)
ja <- 'int#
jacobian (double , const double y[], double *dfdy,#
	  double dfdt[], void *params_ptr)#
{#
  // get parameter(s) from params_ptr; here, just a double #
  double mu = *(double *) params_ptr;#
#
  gsl_matrix_view dfdy_mat = gsl_matrix_view_array (dfdy, 2, 2);#
#
  gsl_matrix *m_ptr = &dfdy_mat.matrix;	// m_ptr points to the matrix #
#
  // fill the Jacobian matrix as shown #
  gsl_matrix_set (m_ptr, 0, 0, 0.0);	// df[0]/dy[0] = 0 #
  gsl_matrix_set (m_ptr, 0, 1, 1.0);	// df[0]/dy[1] = 1 #
  gsl_matrix_set (m_ptr, 1, 0, -2.0 * mu * y[0] * y[1] - 1.0);	// df[1]/dy[0] #
  gsl_matrix_set (m_ptr, 1, 1, -mu * (y[0] * y[0] - 1.0));	// df[1]/dy[1] #
#
  // set explicit t dependence of f[i] #
  dfdt[0] = 0.0;#
  dfdt[1] = 0.0;#
#
  return GSL_SUCCESS;		// GSL_SUCCESS defined in gsl/errno.h as 0 #
}#
'
rhs <- 'int#
rhs (double , const double y[], double f[], void *params_ptr)#
{#
  // get parameter(s) from params_ptr; here, just a double #
  double mu = *(double *) params_ptr;#
#
  // evaluate the right-hand-side functions at t #
  f[0] = y[1];#
  f[1] = -y[0] + mu * y[1] * (1. - y[0] * y[0]);#
#
  return GSL_SUCCESS;		// GSL_SUCCESS defined in gsl/errno.h as 0 #
}#
'
func <- 'int#
main (void)#
{#
  int dimension = 2;		// number of differential equations #
#
  double eps_abs = 1.e-8;	// absolute error requested #
  double eps_rel = 1.e-10;	// relative error requested #
#
  // define the type of routine for making steps: #
  const gsl_odeiv_step_type *type_ptr = gsl_odeiv_step_rkf45;#
  // some other possibilities (see GSL manual):          #
  //   = gsl_odeiv_step_rk4;#
  //   = gsl_odeiv_step_rkck;#
  //   = gsl_odeiv_step_rk8pd;#
  //   = gsl_odeiv_step_rk4imp;#
  //   = gsl_odeiv_step_bsimp;  #
  //   = gsl_odeiv_step_gear1;#
  //   = gsl_odeiv_step_gear2;#
#
  // allocate/initialize the stepper, the control function, and the#
  //  evolution function.#
#
  gsl_odeiv_step *step_ptr = gsl_odeiv_step_alloc (type_ptr, dimension);#
  gsl_odeiv_control *control_ptr = gsl_odeiv_control_y_new (eps_abs, eps_rel);#
  gsl_odeiv_evolve *evolve_ptr = gsl_odeiv_evolve_alloc (dimension);#
#
  gsl_odeiv_system my_system;	// structure with the rhs function, etc. #
#
  double mu = 10;		// parameter for the diffeq #
  double y[2];			// current solution vector #
#
  double t, t_next;		// current and next independent variable #
  double tmin, tmax, delta_t;	// range of t and step size for output #
#
  double h = 1e-6;		// starting step size for ode solver #
#
  // load values into the my_system structure #
  my_system.function = rhs;	// the right-hand-side functions dy[i]/dt #
  my_system.jacobian = jacobian;	// the Jacobian df[i]/dy[j] #
  my_system.dimension = dimension;	// number of diffeq's #
  my_system.params = &mu;	// parameters to pass to rhs and jacobian #
#
  tmin = 0.;			// starting t value #
  tmax = 100.;			// final t value #
  delta_t = 1.;#
#
  y[0] = 1.;			// initial x value #
  y[1] = 0.;			// initial v value #
#
  t = tmin;			// initialize t #
#
  // print initial values#
  cout << scientific << setprecision (5) << setw (12) << t << " " #
    << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
#
  // step to tmax from tmin #
  for (t_next = tmin + delta_t; t_next <= tmax; t_next += delta_t)#
    {#
      while (t < t_next)	// evolve from t to t_next #
	{#
	  gsl_odeiv_evolve_apply (evolve_ptr, control_ptr, step_ptr,#
				  &my_system, &t, t_next, &h, y);#
	}#
#
      // print at t = t_next#
      cout << scientific << setprecision (5) << setw (12) << t << " " #
        << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
    }#
#
  // all done; free up the gsl_odeiv stuff #
  gsl_odeiv_evolve_free (evolve_ptr);#
  gsl_odeiv_control_free (control_ptr);#
  gsl_odeiv_step_free (step_ptr);#
#
  return 0;#
}'
func <- 'int#
main (void)#
{#
  int dimension = 2;		// number of differential equations #
#
  double eps_abs = 1.e-8;	// absolute error requested #
  double eps_rel = 1.e-10;	// relative error requested #
#
  // define the type of routine for making steps: #
  const gsl_odeiv_step_type *type_ptr = gsl_odeiv_step_rkf45;#
  // some other possibilities (see GSL manual):          #
  //   = gsl_odeiv_step_rk4;#
  //   = gsl_odeiv_step_rkck;#
  //   = gsl_odeiv_step_rk8pd;#
  //   = gsl_odeiv_step_rk4imp;#
  //   = gsl_odeiv_step_bsimp;  #
  //   = gsl_odeiv_step_gear1;#
  //   = gsl_odeiv_step_gear2;#
#
  // allocate/initialize the stepper, the control function, and the#
  //  evolution function.#
#
  gsl_odeiv_step *step_ptr = gsl_odeiv_step_alloc (type_ptr, dimension);#
  gsl_odeiv_control *control_ptr = gsl_odeiv_control_y_new (eps_abs, eps_rel);#
  gsl_odeiv_evolve *evolve_ptr = gsl_odeiv_evolve_alloc (dimension);#
#
  gsl_odeiv_system my_system;	// structure with the rhs function, etc. #
#
  double mu = 10;		// parameter for the diffeq #
  double y[2];			// current solution vector #
#
  double t, t_next;		// current and next independent variable #
  double tmin, tmax, delta_t;	// range of t and step size for output #
#
  double h = 1e-6;		// starting step size for ode solver #
#
  // load values into the my_system structure #
  my_system.function = rhs;	// the right-hand-side functions dy[i]/dt #
  my_system.jacobian = jacobian;	// the Jacobian df[i]/dy[j] #
  my_system.dimension = dimension;	// number of diffeqs #
  my_system.params = &mu;	// parameters to pass to rhs and jacobian #
#
  tmin = 0.;			// starting t value #
  tmax = 100.;			// final t value #
  delta_t = 1.;#
#
  y[0] = 1.;			// initial x value #
  y[1] = 0.;			// initial v value #
#
  t = tmin;			// initialize t #
#
  // print initial values#
  cout << scientific << setprecision (5) << setw (12) << t << " " #
    << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
#
  // step to tmax from tmin #
  for (t_next = tmin + delta_t; t_next <= tmax; t_next += delta_t)#
    {#
      while (t < t_next)	// evolve from t to t_next #
	{#
	  gsl_odeiv_evolve_apply (evolve_ptr, control_ptr, step_ptr,#
				  &my_system, &t, t_next, &h, y);#
	}#
#
      // print at t = t_next#
      cout << scientific << setprecision (5) << setw (12) << t << " " #
        << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
    }#
#
  // all done; free up the gsl_odeiv stuff #
  gsl_odeiv_evolve_free (evolve_ptr);#
  gsl_odeiv_control_free (control_ptr);#
  gsl_odeiv_step_free (step_ptr);#
#
  return 0;#
}'
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h>",#
                        Rcpp=TRUE)
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h>",#
                        Rcpp=F)
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h> #include <gsl/gsl_matrix.h> #include<gsl/gsl_odeiv.h> #include <gsl/gsl_errno.h>",#
                        Rcpp=F)
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h> #
                        #include <gsl/gsl_matrix.h> #
                        #include<gsl/gsl_odeiv.h> #
                        #include <gsl/gsl_errno.h>",#
                        Rcpp=F)
func <- '#
  int dimension = 2;		// number of differential equations #
#
  double eps_abs = 1.e-8;	// absolute error requested #
  double eps_rel = 1.e-10;	// relative error requested #
#
  // define the type of routine for making steps: #
  const gsl_odeiv_step_type *type_ptr = gsl_odeiv_step_rkf45;#
  // some other possibilities (see GSL manual):          #
  //   = gsl_odeiv_step_rk4;#
  //   = gsl_odeiv_step_rkck;#
  //   = gsl_odeiv_step_rk8pd;#
  //   = gsl_odeiv_step_rk4imp;#
  //   = gsl_odeiv_step_bsimp;  #
  //   = gsl_odeiv_step_gear1;#
  //   = gsl_odeiv_step_gear2;#
#
  // allocate/initialize the stepper, the control function, and the#
  //  evolution function.#
#
  gsl_odeiv_step *step_ptr = gsl_odeiv_step_alloc (type_ptr, dimension);#
  gsl_odeiv_control *control_ptr = gsl_odeiv_control_y_new (eps_abs, eps_rel);#
  gsl_odeiv_evolve *evolve_ptr = gsl_odeiv_evolve_alloc (dimension);#
#
  gsl_odeiv_system my_system;	// structure with the rhs function, etc. #
#
  double mu = 10;		// parameter for the diffeq #
  double y[2];			// current solution vector #
#
  double t, t_next;		// current and next independent variable #
  double tmin, tmax, delta_t;	// range of t and step size for output #
#
  double h = 1e-6;		// starting step size for ode solver #
#
  // load values into the my_system structure #
  my_system.function = rhs;	// the right-hand-side functions dy[i]/dt #
  my_system.jacobian = jacobian;	// the Jacobian df[i]/dy[j] #
  my_system.dimension = dimension;	// number of diffeqs #
  my_system.params = &mu;	// parameters to pass to rhs and jacobian #
#
  tmin = 0.;			// starting t value #
  tmax = 100.;			// final t value #
  delta_t = 1.;#
#
  y[0] = 1.;			// initial x value #
  y[1] = 0.;			// initial v value #
#
  t = tmin;			// initialize t #
#
  // print initial values#
  cout << scientific << setprecision (5) << setw (12) << t << " " #
    << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
#
  // step to tmax from tmin #
  for (t_next = tmin + delta_t; t_next <= tmax; t_next += delta_t)#
    {#
      while (t < t_next)	// evolve from t to t_next #
	{#
	  gsl_odeiv_evolve_apply (evolve_ptr, control_ptr, step_ptr,#
				  &my_system, &t, t_next, &h, y);#
	}#
#
      // print at t = t_next#
      cout << scientific << setprecision (5) << setw (12) << t << " " #
        << setw (12) << y[0] << " " << setw (12) << y[1] << endl;#
    }#
#
  // all done; free up the gsl_odeiv stuff #
  gsl_odeiv_evolve_free (evolve_ptr);#
  gsl_odeiv_control_free (control_ptr);#
  gsl_odeiv_step_free (step_ptr);#
#
  return 0;#
'
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h> #
                        #include <gsl/gsl_matrix.h> #
                        #include<gsl/gsl_odeiv.h> #
                        #include <gsl/gsl_errno.h>",#
                        Rcpp=F)
funx <- cfunction(signature(), func,#
                        includes="#include <gsl/gsl_rng.h>#
#include <gsl/gsl_matrix.h>#
#include<gsl/gsl_odeiv.h>#
#include <gsl/gsl_errno.h>",#
                        Rcpp=F)
gc(T)
ls()
source("~/Documents/work/PBM_Analysis/src/code.R")#
source("~/Documents/work/PBM_Analysis/src/util.R")#
source("~/tmp/PBM.R")#
#
make.full.from.halfsite <- function(par, halfsite.len, spacer.len, free.pos) {#
  halfsite.idx = 1:(4*halfsite.len)#
  halfsite.values = par[1:(3*halfsite.len)]#
  #
  if(spacer.len>0) {#
    spacer.idx = (4*halfsite.len+1):(4*halfsite.len+4*spacer.len)#
    spacer.values = par[(3*halfsite.len+1):(3*halfsite.len+3*spacer.len)]#
    flip.halfsite.idx = (max(spacer.idx)+1):(length(halfsite.idx)+max(spacer.idx))#
  } else {#
    flip.halfsite.idx = (max(halfsite.idx)+1):(length(halfsite.idx)+max(halfsite.idx))#
  }#
  #
  mtx = rep(0,4*(2*halfsite.len+spacer.len))#
  mtx[halfsite.idx[free.pos[halfsite.idx]]] = halfsite.values#
  if (spacer.len > 0) {mtx[spacer.idx[free.pos[spacer.idx]]] = spacer.values}#
  mtx[flip.halfsite.idx[rev(free.pos[halfsite.idx])]] = rev(halfsite.values)#
  mtx#
}#
#
predict.occupancy <- function(mtx,seqs.01,idx.f, idx.r, pos.weights, orientation.weight = 1, boltzmann=F) {#
  if (boltzmann) {#
    p = exp(-seqs.01 %*% mtx)#
  } else {#
    p = 1/(1+exp(seqs.01%*%mtx))#
  }#
  pf = matrix(p[idx.f],ncol=ncol(idx.f))#
  pnf = 1-pf#
  pr = matrix(p[idx.r],ncol=ncol(idx.r))#
  (pf + pnf * pr*orientation.weight) %*% pos.weights#
}#
#
beeml.ob.f.sum <- function(para, free.pos, target, idx.f, idx.r, position.weights, seqs.01, probe.weights, orientation.weight = 1, boltzmann=F, lambda = 0.1){#
  pred = predict.occupancy(para, seqs.01, idx.f, idx.r, position.weights, orientation.weight, boltzmann)#
  # don't penalize mu#
  if (boltzmann) {#
    pen = lambda * para#
  } else {#
    pen = lambda * para[1:(length(para)-1)]#
  }#
  c(lm(target~pred)$residuals * probe.weights, pen)#
}#
#
beeml.ob.f.pali.sum <- function(par, halfsite.len, spacer.len, free.pos, target, idx.f, idx.r, position.weights, seqs.01, probe.weights, orientation.weight = 1, boltzmann=F, lambda=0.1){#
#
  mtx = make.full.from.halfsite(par[1:(3*halfsite.len)],halfsite.len, spacer.len,free.pos)#
  mtx.f = mtx[c(free.pos, rev(free.pos))]#
  if (boltzmann) {#
    pred = predict.occupancy(mtx.f, mu, seqs.01, idx.f, idx.r, position.weights, orientation.weight, boltzmann)#
  } else {#
    mu = par[length(par)]#
    pred = predict.occupancy(c(mtx.f, mu), cbind(seqs.01,-1), idx.f, idx.r, position.weights, orientation.weight, boltzmann)#
  }#
  #
  c(lm(target~pred)$residuals * probe.weights, lambda * mtx.f)#
}#
#
get.beeml.solution.sum <- function(values, idx.f, idx.r, position.weights, seed.mtx, seqs.01 = seqs.n.01, palidromic = F, nprint = 0, ignore.background=F, halfsite.len=5, spacer.len=0, orientation.weight = 1, boltzmann=F, lambda = 0, maxiter = 15) {#
  # get rid of na values.#
  good.idx = !is.na(values)#
  good.values = values[good.idx]#
  good.idx.f = idx.f[good.idx,]#
  good.idx.r = idx.r[good.idx,]#
#
  if (ignore.background) {#
    bg.weights = rep(1,length(good.values))#
  } else {#
    # have to take the square root, since nls.lm takes residuals rather than square of residuals, so weights have to be adjusted accordingly#
    bg.weights = sqrt(est.bg.weights(good.values))#
  }#
  # make sure consensus of seed matrix is set to 0#
  seed.mtx = as.vector(apply(matrix(seed.mtx,4),2,function(x) x-min(x)))#
  #
  if (palidromic) {#
    seqs.f  = seqs.01[,c(seed.mtx, rev(seed.mtx)) > 0]#
    f.pos = seed.mtx>0#
    ## sol = nls.lm(runif(sum(f.pos)+1),  fn = beeml.ob.f.pali, target = values[good.idx]#
    if (boltzmann) {#
      sol = nls.lm(seed.mtx[f.pos], fn = beeml.ob.f.pali.sum, target = good.values, halfsite.len = halfsite.len, spacer.len = spacer.len, free.pos = f.pos, idx.f = good.idx.f, idx.r = good.idx.r, position.weights = position.weights, seqs.01 = seqs.f, probe.weights = bg.weights, boltzmann = boltzmann,lambda = lambda, control = nls.lm.control(nprint=nprint,maxiter=maxiter))#
    } else {#
      sol = nls.lm(c(seed.mtx[f.pos],2), fn = beeml.ob.f.pali.sum, target = good.values, halfsite.len = halfsite.len, spacer.len = spacer.len, free.pos = f.pos, idx.f = good.idx.f, idx.r = good.idx.r, position.weights = position.weights, seqs.01 = seqs.f, probe.weights = bg.weights, boltzmann = boltzmann,lambda = lambda, control = nls.lm.control(nprint=nprint,maxiter=maxiter))      #
    }#
  }#
  else {#
    f.pos = seed.mtx > 0#
    seqs.f = seqs.01[,f.pos]#
    if (boltzmann) {#
       sol = nls.lm(seed.mtx[f.pos], fn = beeml.ob.f.sum, target = good.values, free.pos = f.pos, idx.f = good.idx.f, idx.r = good.idx.r, position.weights = position.weights, seqs.01 = seqs.f, probe.weights = bg.weights, boltzmann = boltzmann, lambda = lambda, orientation.weight  = orientation.weight , control = nls.lm.control(nprint=nprint,maxiter=maxiter))#
    } else {#
      seqs.f = cbind(seqs.f, -1)#
      sol = nls.lm(c(seed.mtx[f.pos],2), fn = beeml.ob.f.sum, target = good.values, free.pos = f.pos, idx.f = good.idx.f, idx.r = good.idx.r, position.weights = position.weights, seqs.01 = seqs.f, probe.weights = bg.weights, boltzmann = boltzmann, lambda = lambda, orientation.weight  = orientation.weight , control = nls.lm.control(nprint=nprint,maxiter=maxiter))#
    }#
  }#
  sol#
}#
#
#
# load zhu et. al. yeast data#
load("/Users/zhaoyue/Documents/work/PBM_Analysis/Data/Zhu09/good.8mer.idx")#
#
load("/Users/zhaoyue/Documents/work/PBM_Analysis/Data/Zhu09/v1.RData")#
load("/Users/zhaoyue/Documents/work/PBM_Analysis/Data/Zhu09/v2.RData")
gc(T)
ls()
x = make.kmers.wyk(10)
object.size(x)
object.size(x)/1e6
rm(x)
gc(T)
x = make.kmers.01(10)
object.size(x)/1e6
gc(T)
encode.wyk.di
z = apply(x,1,decode01)
gc(T)
x.di = sapply(z,encode.wyk.di)
gc(T)
rm(x)
gc(T)
encode.wyk.di(z[1])
length(encode.wyk.di(z[1]))
length(z)
x.di = matrix(0,nrow=1048576, ncol=111)
system.time({for(i in 1:1048576) x.di[i,] = encode.wyk.di[z[i]]})
system.time({for(i in 1:1048576) x.di[i,] = encode.wyk.di(z[i])})
dim(x.di)
class(x.di)
class(x.di[1])
gc(T)
x.di = as.integer(x.di)
encode.wyk.di
encode.wyk.di <- function(kmer) {#
  out = c()#
  len = nchar(kmer)#
  if (len >= 2) {#
    tr.mtx = mk.wyk.di.tr.mtx()#
    out = tr.mtx[rownames(tr.mtx)==substr(kmer,1,2),]#
    i = 3#
    while (i <= len) {#
      out = c(out, tr.mtx[rownames(tr.mtx)==substr(kmer,i-1,i),][4:15])#
      i = i + 1#
    }#
  }#
  as.integer(out)#
}
class(encode.wyk.di("AAAAAAAAAA"))
2460/60
for (i in 1:nrow(x.di)) x.di[i,] = as.integer(x.di[i,])
x.di[1,]
as.integer(x.di[1,])
x.di[1,] = as.integer(x.di[1,])
system.time({for(i in 1:1048576) x.di[i,] = encode.wyk.di(z[i])})
gc(T)
for (i in 1:ncol(x.di))
for (j in 1:ncol(x.di))
x.di[i,j] = as.integer(x.di[i,j])
gc(T)
rm(x.di)
gc(T)
x.di = matrix(as.integer(0),nrow=4^10, ncol=111)
class(x.di)
class(x.di[1,1])
gc(T)
system.time({for(i in 1:1048576) x.di[i,] = encode.wyk.di(z[i])})
gc(T)
system.time({tiger = x.di %*% rnorm(111,4,3)})
gc(T)
?"Memory-limits"
save(x.di, file="seqs.01.wyk.di.RObject")
setwd("~/tmp/BEEML_PBM_Example")
source("example.R")
source("example.R")
source("example.R")
source("example.R")
source("example.R")
system.time({source("example.R")})
917/60
print.logo(pbm.sol$mtx)
2.4/1.1
1.1/2.4
log(2)
## data files are from uniprobe database http://thebrain.bwh.harvard.edu/uniprobe/downloads.php#
## first column is normalized probe intensity, second column is probe sequence#
#
data.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30_v9_deBruijn.txt"#
seed.pwm.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30.pwm"#
#
source("./code.R")#
source("./PBM_util.R")#
#
L = 10#
all.seqs.01.l = make.kmers.01(L)#
all.seqs.01.8 = make.kmers.01(8)#
#
## list of 8mers that does not include reverse complement of itself#
i=1#
seen = new.env(hash=T)#
for(i in 1:nrow(all.seqs.01.8)) {#
  word.revcomp.seen = exists(decode01(rev(all.seqs.01.8[i,])), envir=seen)#
  if ( !word.revcomp.seen ) assign(decode01(all.seqs.01.8[i,]),i,envir=seen)#
}#
x = ls(envir=seen)#
good.8mer.idx = sapply(x, function(idx) get(idx,envir=seen))#
#
rm(i)#
rm(x)#
rm(seen)#
rm(word.revcomp.seen)#
#
#
#
pbm.data = read.table(data.file, as.is=T)#
#
#
## process sequence. this only needs to be done once for each array design, takes ~8 minutes on an imac (2006 model)#
## probe sequences from Badis et. al. have 36 long variable region, I take the sequences of the first 40 bases into account#
## which includes some of the costant region.#
var.len = 40#
num.lmers = var.len - L + 1#
#
var.seqs = sapply(pbm.data[,2], function(seq) substr(seq, 1, var.len))#
var.seqs.01 = t(sapply(var.seqs, encode01))#
#
## for each 8mer, figure out which probe contains it#
## pbm.8mer.probes.idx is a list, each element of which is the vector of probe indices that contain a particular 8mer, in either orientation#
num.8mers = var.len - 8 + 1#
pbm.8mer.probes.idx = list()#
pbm.8mer.probes.idx[4^8+1]=NA#
start.pos = seq(1, by=4, length.out=num.8mers)#
for(probe.idx in 1:nrow(var.seqs.01)) {#
  for (start in start.pos) {#
    word = var.seqs.01[probe.idx, start:(start+(4*8-1))]#
    word.idx = find.idx.01(word)#
    word.revcomp.idx = find.idx.01(rev(word))#
    pbm.8mer.probes.idx[[word.idx]] = c(pbm.8mer.probes.idx[[word.idx]], probe.idx)#
    pbm.8mer.probes.idx[[word.revcomp.idx]] = c(pbm.8mer.probes.idx[[word.revcomp.idx]], probe.idx)#
  }#
}#
pbm.8mer.probes.idx = lapply(pbm.8mer.probes.idx[1:(4^8)],unique)#
pbm.probes.8mer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+8*4-1)]))))#
pbm.probes.8mer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+8*4-1)]))}))#
#
## for each probe, figure out which L-mer are on it.#
start.pos = seq(1, by=4, length.out=num.lmers)#
pbm.probes.lmer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+L*4-1)]))))#
pbm.probes.lmer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+L*4-1)]))}))#
#
#
## figure out the position weights, the same sequence seem to have more signal farther away from the glass#
pbm.8mer.medians = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.data[x,1],na.rm=T)))#
num.top.8mers = 50#
top.8mers = apply(all.seqs.01.8[order(pbm.8mer.medians,decreasing=T)[1:num.top.8mers],],1,decode01)#
pbm.position.weights = est.position.weights(0, 0, var.seqs, pbm.data[,1],kmers = top.8mers)#
pbm.position.weights = c(pbm.position.weights, rep(pbm.position.weights[length(pbm.position.weights)], 40 - length(pbm.position.weights)))#
#
## 8mer median intensities explain ~80% of variance of probe intensities?#
pbm.8mers.pred = apply(cbind(pbm.probes.8mer.idx.f, pbm.probes.8mer.idx.r), 1, function(x) max(pbm.8mer.medians[x] %*% c(pbm.position.weights[1:ncol(pbm.probes.8mer.idx.f)], pbm.position.weights[1:ncol(pbm.probes.8mer.idx.r)])))#
pbm.8mers.pred.rsqr = round(cor(pbm.8mers.pred, pbm.data[,1])^2,2)#
#
#
## take L contigous columns with highest information from uniprobe pwm to use as starting position for optimization#
seed.mtx = get.high.information.positions(as.matrix(read.table(seed.pwm.file,skip=1)[,-1]), L, F)#
pbm.sol = get.beeml.solution.sum(values = pbm.data[,1]/sd(pbm.data[,1],na.rm=T), idx.f = pbm.probes.lmer.idx.f, idx.r = pbm.probes.lmer.idx.r, position.weights = pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)], seed.mtx = seed.mtx, seqs.01 = all.seqs.01.l, palidromic = F, nprint = 1, lambda = 0.1)#
#
## how well does the beeml regression model perform?#
## fit at the probe level#
pbm.beeml.pred = predict.occupancy(cbind(pbm.sol$mtx, pbm.sol$mu), all.seqs.01.l, pbm.probes.lmer.idx.f, pbm.probes.lmer.idx.r, pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)])#
pbm.beeml.pred.rsqr = round(cor(pbm.beeml.pred, pbm.data[,1])^2,2)#
## fit at the 8mer median intensity level, excluding reverse complements#
pbm.beeml.pred.8mers = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.beeml.pred[x],na.rm=T)))#
pbm.beeml.pred.8mers.rsqr = round(cor(pbm.beeml.pred.8mers[good.8mer.idx], pbm.8mer.medians[good.8mer.idx])^2,2)#
#
## make a plot of the results#
par(mfrow=c(2,2),pch=16,col=rgb(0,0,1,0.8),bty="n")#
hist(pbm.data[,1],breaks="Scott",main="Histogram of Probe Intensities")#
plot(pbm.8mers.pred, pbm.data[,1], main=paste("Probe Intensities from 8mer medians\n R^2 =", pbm.8mers.pred.rsqr), xlab="8mer predicted probe intensities", ylab="Probe Intensities")#
plot(pbm.beeml.pred.8mers, pbm.8mer.medians, main=paste("BEEML Fit on 8mer Median Intensities\n R^2 =", pbm.beeml.pred.8mers.rsqr), xlab="BEEML predicted 8mer medians", ylab="PBM 8mer Median Intensities")#
plot(pbm.beeml.pred, pbm.data[,1], main=paste("Probe Intensities from BEEML model\n R^2 =", pbm.beeml.pred.rsqr), xlab="BEEML predicted probe intensities", ylab="PBM Probe Intensities")
print.logo(pbm.sol$mtx)
## data files are from uniprobe database http://thebrain.bwh.harvard.edu/uniprobe/downloads.php#
## first column is normalized probe intensity, second column is probe sequence#
#
data.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30_v11_deBruijn.txt"#
seed.pwm.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30.pwm"#
#
source("./code.R")#
source("./PBM_util.R")#
#
L = 10#
all.seqs.01.l = make.kmers.01(L)#
all.seqs.01.8 = make.kmers.01(8)#
#
## list of 8mers that does not include reverse complement of itself#
i=1#
seen = new.env(hash=T)#
for(i in 1:nrow(all.seqs.01.8)) {#
  word.revcomp.seen = exists(decode01(rev(all.seqs.01.8[i,])), envir=seen)#
  if ( !word.revcomp.seen ) assign(decode01(all.seqs.01.8[i,]),i,envir=seen)#
}#
x = ls(envir=seen)#
good.8mer.idx = sapply(x, function(idx) get(idx,envir=seen))#
#
rm(i)#
rm(x)#
rm(seen)#
rm(word.revcomp.seen)#
#
#
#
pbm.data = read.table(data.file, as.is=T)#
#
#
## process sequence. this only needs to be done once for each array design, takes ~8 minutes on an imac (2006 model)#
## probe sequences from Badis et. al. have 36 long variable region, I take the sequences of the first 40 bases into account#
## which includes some of the costant region.#
var.len = 40#
num.lmers = var.len - L + 1#
#
var.seqs = sapply(pbm.data[,2], function(seq) substr(seq, 1, var.len))#
var.seqs.01 = t(sapply(var.seqs, encode01))#
#
## for each 8mer, figure out which probe contains it#
## pbm.8mer.probes.idx is a list, each element of which is the vector of probe indices that contain a particular 8mer, in either orientation#
num.8mers = var.len - 8 + 1#
pbm.8mer.probes.idx = list()#
pbm.8mer.probes.idx[4^8+1]=NA#
start.pos = seq(1, by=4, length.out=num.8mers)#
for(probe.idx in 1:nrow(var.seqs.01)) {#
  for (start in start.pos) {#
    word = var.seqs.01[probe.idx, start:(start+(4*8-1))]#
    word.idx = find.idx.01(word)#
    word.revcomp.idx = find.idx.01(rev(word))#
    pbm.8mer.probes.idx[[word.idx]] = c(pbm.8mer.probes.idx[[word.idx]], probe.idx)#
    pbm.8mer.probes.idx[[word.revcomp.idx]] = c(pbm.8mer.probes.idx[[word.revcomp.idx]], probe.idx)#
  }#
}#
pbm.8mer.probes.idx = lapply(pbm.8mer.probes.idx[1:(4^8)],unique)#
pbm.probes.8mer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+8*4-1)]))))#
pbm.probes.8mer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+8*4-1)]))}))#
#
## for each probe, figure out which L-mer are on it.#
start.pos = seq(1, by=4, length.out=num.lmers)#
pbm.probes.lmer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+L*4-1)]))))#
pbm.probes.lmer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+L*4-1)]))}))#
#
#
## figure out the position weights, the same sequence seem to have more signal farther away from the glass#
pbm.8mer.medians = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.data[x,1],na.rm=T)))#
num.top.8mers = 50#
top.8mers = apply(all.seqs.01.8[order(pbm.8mer.medians,decreasing=T)[1:num.top.8mers],],1,decode01)#
pbm.position.weights = est.position.weights(0, 0, var.seqs, pbm.data[,1],kmers = top.8mers)#
pbm.position.weights = c(pbm.position.weights, rep(pbm.position.weights[length(pbm.position.weights)], 40 - length(pbm.position.weights)))#
#
## 8mer median intensities explain ~80% of variance of probe intensities?#
pbm.8mers.pred = apply(cbind(pbm.probes.8mer.idx.f, pbm.probes.8mer.idx.r), 1, function(x) max(pbm.8mer.medians[x] %*% c(pbm.position.weights[1:ncol(pbm.probes.8mer.idx.f)], pbm.position.weights[1:ncol(pbm.probes.8mer.idx.r)])))#
pbm.8mers.pred.rsqr = round(cor(pbm.8mers.pred, pbm.data[,1])^2,2)#
#
#
## take L contigous columns with highest information from uniprobe pwm to use as starting position for optimization#
seed.mtx = get.high.information.positions(as.matrix(read.table(seed.pwm.file,skip=1)[,-1]), L, F)#
pbm.sol = get.beeml.solution.sum(values = pbm.data[,1]/sd(pbm.data[,1],na.rm=T), idx.f = pbm.probes.lmer.idx.f, idx.r = pbm.probes.lmer.idx.r, position.weights = pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)], seed.mtx = seed.mtx, seqs.01 = all.seqs.01.l, palidromic = F, nprint = 1, lambda = 0.1)#
#
## how well does the beeml regression model perform?#
## fit at the probe level#
pbm.beeml.pred = predict.occupancy(cbind(pbm.sol$mtx, pbm.sol$mu), all.seqs.01.l, pbm.probes.lmer.idx.f, pbm.probes.lmer.idx.r, pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)])#
pbm.beeml.pred.rsqr = round(cor(pbm.beeml.pred, pbm.data[,1])^2,2)#
## fit at the 8mer median intensity level, excluding reverse complements#
pbm.beeml.pred.8mers = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.beeml.pred[x],na.rm=T)))#
pbm.beeml.pred.8mers.rsqr = round(cor(pbm.beeml.pred.8mers[good.8mer.idx], pbm.8mer.medians[good.8mer.idx])^2,2)#
#
## make a plot of the results#
par(mfrow=c(2,2),pch=16,col=rgb(0,0,1,0.8),bty="n")#
hist(pbm.data[,1],breaks="Scott",main="Histogram of Probe Intensities")#
plot(pbm.8mers.pred, pbm.data[,1], main=paste("Probe Intensities from 8mer medians\n R^2 =", pbm.8mers.pred.rsqr), xlab="8mer predicted probe intensities", ylab="Probe Intensities")#
plot(pbm.beeml.pred.8mers, pbm.8mer.medians, main=paste("BEEML Fit on 8mer Median Intensities\n R^2 =", pbm.beeml.pred.8mers.rsqr), xlab="BEEML predicted 8mer medians", ylab="PBM 8mer Median Intensities")#
plot(pbm.beeml.pred, pbm.data[,1], main=paste("Probe Intensities from BEEML model\n R^2 =", pbm.beeml.pred.rsqr), xlab="BEEML predicted probe intensities", ylab="PBM Probe Intensities")
print.logo(pbm.sol$mtx)
png("HLH30.v11.fit.png",width=10,height=10,units="in",res=150)
par(mfrow=c(2,2),pch=16,col=rgb(0,0,1,0.8),bty="n")#
 hist(pbm.data[,1],breaks="Scott",main="Histogram of Probe Intensities")#
 plot(pbm.8mers.pred, pbm.data[,1], main=paste("Probe Intensities from 8mer medians\n R^2 =", pbm.8mers.pred.rsqr), xlab="8mer predicted probe intensities", ylab="Probe Intensities")#
 plot(pbm.beeml.pred.8mers, pbm.8mer.medians, main=paste("BEEML Fit on 8mer Median Intensities\n R^2 =", pbm.beeml.pred.8mers.rsqr), xlab="BEEML predicted 8mer medians", ylab="PBM 8mer Median Intensities")#
 plot(pbm.beeml.pred, pbm.data[,1], main=paste("Probe Intensities from BEEML model\n R^2 =", pbm.beeml.pred.rsqr), xlab="BEEML predicted probe intensities", ylab="PBM Probe Intensities")
dev.off()
png("HLH30.v11.logo.png",width=10,height=10,units="in",res=150)
print.logo(pbm.sol$mtx)
dev.off()
## data files are from uniprobe database http://thebrain.bwh.harvard.edu/uniprobe/downloads.php#
## first column is normalized probe intensity, second column is probe sequence#
#
data.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30_v9_deBruijn.txt"#
seed.pwm.file = "/Users/zhaoyue/Documents/Binding Data/PBM Data, new format/data/PBMD/Groves Cell 09/HLH-30/HLH-30.pwm"#
#
source("./code.R")#
source("./PBM_util.R")#
#
L = 10#
all.seqs.01.l = make.kmers.01(L)#
all.seqs.01.8 = make.kmers.01(8)#
#
## list of 8mers that does not include reverse complement of itself#
i=1#
seen = new.env(hash=T)#
for(i in 1:nrow(all.seqs.01.8)) {#
  word.revcomp.seen = exists(decode01(rev(all.seqs.01.8[i,])), envir=seen)#
  if ( !word.revcomp.seen ) assign(decode01(all.seqs.01.8[i,]),i,envir=seen)#
}#
x = ls(envir=seen)#
good.8mer.idx = sapply(x, function(idx) get(idx,envir=seen))#
#
rm(i)#
rm(x)#
rm(seen)#
rm(word.revcomp.seen)#
#
#
#
pbm.data = read.table(data.file, as.is=T)#
#
#
## process sequence. this only needs to be done once for each array design, takes ~8 minutes on an imac (2006 model)#
## probe sequences from Badis et. al. have 36 long variable region, I take the sequences of the first 40 bases into account#
## which includes some of the costant region.#
var.len = 40#
num.lmers = var.len - L + 1#
#
var.seqs = sapply(pbm.data[,2], function(seq) substr(seq, 1, var.len))#
var.seqs.01 = t(sapply(var.seqs, encode01))#
#
## for each 8mer, figure out which probe contains it#
## pbm.8mer.probes.idx is a list, each element of which is the vector of probe indices that contain a particular 8mer, in either orientation#
num.8mers = var.len - 8 + 1#
pbm.8mer.probes.idx = list()#
pbm.8mer.probes.idx[4^8+1]=NA#
start.pos = seq(1, by=4, length.out=num.8mers)#
for(probe.idx in 1:nrow(var.seqs.01)) {#
  for (start in start.pos) {#
    word = var.seqs.01[probe.idx, start:(start+(4*8-1))]#
    word.idx = find.idx.01(word)#
    word.revcomp.idx = find.idx.01(rev(word))#
    pbm.8mer.probes.idx[[word.idx]] = c(pbm.8mer.probes.idx[[word.idx]], probe.idx)#
    pbm.8mer.probes.idx[[word.revcomp.idx]] = c(pbm.8mer.probes.idx[[word.revcomp.idx]], probe.idx)#
  }#
}#
pbm.8mer.probes.idx = lapply(pbm.8mer.probes.idx[1:(4^8)],unique)#
pbm.probes.8mer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+8*4-1)]))))#
pbm.probes.8mer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+8*4-1)]))}))#
#
## for each probe, figure out which L-mer are on it.#
start.pos = seq(1, by=4, length.out=num.lmers)#
pbm.probes.lmer.idx.f = t(apply(var.seqs.01, 1, function(x) sapply(start.pos, function(i) find.idx.01(x[i:(i+L*4-1)]))))#
pbm.probes.lmer.idx.r = t(apply(var.seqs.01, 1, function(x) {y = rev(x);sapply(rev(start.pos), function(i) find.idx.01(y[i:(i+L*4-1)]))}))#
#
#
## figure out the position weights, the same sequence seem to have more signal farther away from the glass#
pbm.8mer.medians = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.data[x,1],na.rm=T)))#
num.top.8mers = 50#
top.8mers = apply(all.seqs.01.8[order(pbm.8mer.medians,decreasing=T)[1:num.top.8mers],],1,decode01)#
pbm.position.weights = est.position.weights(0, 0, var.seqs, pbm.data[,1],kmers = top.8mers)#
pbm.position.weights = c(pbm.position.weights, rep(pbm.position.weights[length(pbm.position.weights)], 40 - length(pbm.position.weights)))#
#
## 8mer median intensities explain ~80% of variance of probe intensities?#
pbm.8mers.pred = apply(cbind(pbm.probes.8mer.idx.f, pbm.probes.8mer.idx.r), 1, function(x) max(pbm.8mer.medians[x] %*% c(pbm.position.weights[1:ncol(pbm.probes.8mer.idx.f)], pbm.position.weights[1:ncol(pbm.probes.8mer.idx.r)])))#
pbm.8mers.pred.rsqr = round(cor(pbm.8mers.pred, pbm.data[,1])^2,2)#
#
#
## take L contigous columns with highest information from uniprobe pwm to use as starting position for optimization#
seed.mtx = get.high.information.positions(as.matrix(read.table(seed.pwm.file,skip=1)[,-1]), L, F)#
pbm.sol = get.beeml.solution.sum(values = pbm.data[,1]/sd(pbm.data[,1],na.rm=T), idx.f = pbm.probes.lmer.idx.f, idx.r = pbm.probes.lmer.idx.r, position.weights = pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)], seed.mtx = seed.mtx, seqs.01 = all.seqs.01.l, palidromic = F, nprint = 1, lambda = 0.1)#
#
## how well does the beeml regression model perform?#
## fit at the probe level#
pbm.beeml.pred = predict.occupancy(cbind(pbm.sol$mtx, pbm.sol$mu), all.seqs.01.l, pbm.probes.lmer.idx.f, pbm.probes.lmer.idx.r, pbm.position.weights[1:ncol(pbm.probes.lmer.idx.f)])#
pbm.beeml.pred.rsqr = round(cor(pbm.beeml.pred, pbm.data[,1])^2,2)#
## fit at the 8mer median intensity level, excluding reverse complements#
pbm.beeml.pred.8mers = unlist(lapply(pbm.8mer.probes.idx, function(x) median(pbm.beeml.pred[x],na.rm=T)))#
pbm.beeml.pred.8mers.rsqr = round(cor(pbm.beeml.pred.8mers[good.8mer.idx], pbm.8mer.medians[good.8mer.idx])^2,2)#
#
## make a plot of the results#
par(mfrow=c(2,2),pch=16,col=rgb(0,0,1,0.8),bty="n")#
hist(pbm.data[,1],breaks="Scott",main="Histogram of Probe Intensities")#
plot(pbm.8mers.pred, pbm.data[,1], main=paste("Probe Intensities from 8mer medians\n R^2 =", pbm.8mers.pred.rsqr), xlab="8mer predicted probe intensities", ylab="Probe Intensities")#
plot(pbm.beeml.pred.8mers, pbm.8mer.medians, main=paste("BEEML Fit on 8mer Median Intensities\n R^2 =", pbm.beeml.pred.8mers.rsqr), xlab="BEEML predicted 8mer medians", ylab="PBM 8mer Median Intensities")#
plot(pbm.beeml.pred, pbm.data[,1], main=paste("Probe Intensities from BEEML model\n R^2 =", pbm.beeml.pred.rsqr), xlab="BEEML predicted probe intensities", ylab="PBM Probe Intensities")
png("HLH30.v9.fit.png",width=10,height=10,units="in",res=150)
par(mfrow=c(2,2),pch=16,col=rgb(0,0,1,0.8),bty="n")#
 hist(pbm.data[,1],breaks="Scott",main="Histogram of Probe Intensities")#
 plot(pbm.8mers.pred, pbm.data[,1], main=paste("Probe Intensities from 8mer medians\n R^2 =", pbm.8mers.pred.rsqr), xlab="8mer predicted probe intensities", ylab="Probe Intensities")#
 plot(pbm.beeml.pred.8mers, pbm.8mer.medians, main=paste("BEEML Fit on 8mer Median Intensities\n R^2 =", pbm.beeml.pred.8mers.rsqr), xlab="BEEML predicted 8mer medians", ylab="PBM 8mer Median Intensities")#
 plot(pbm.beeml.pred, pbm.data[,1], main=paste("Probe Intensities from BEEML model\n R^2 =", pbm.beeml.pred.rsqr), xlab="BEEML predicted probe intensities", ylab="PBM Probe Intensities")
dev.off()
png("HLH30.v9.logo.png",width=10,height=10,units="in",res=150)
print.logo(pbm.sol$mtx)
dev.off()
summary(pbm.data[order(pbm.data[,1],decreasing=T)[-c(1,2)],])
